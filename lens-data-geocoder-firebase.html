<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../firebase-element/firebase-document.html">
<link rel="import" href="../firebase-element/firebase-collection.html">
<link rel="import" href="../iron-selector/iron-selector.html"> 
<link rel="import" href="../google-apis/google-maps-api.html">

<!--
A data transform component that converts data into latitude / longitude or vice
versa and saves the results to<a href="https://www.firebase.com/" 
target="_blank">Firebase</a>.

##### Example

    <lens-data-geocoder-firebase></lens-data-geocoder-firebase>

@element lens-data-geocoder-firebase
@blurb A transform component that converts locations into
latitude / longitude or vice versa and saves the results to Firebase.
@status alpha
@homepage http://lenses.github.io/lens-data-geocoder-firebase
-->
<dom-module id="lens-data-geocoder-firebase">
  <style>
      :host {
        width: 150px;
      }
      
      iron-selector {
        min-height: 10px;
        display: inline-block;
        max-height: 123px;
        /*overflow-y: scroll; */
      }

      iron-selector .col {
        padding: 1px;
        border: 1px solid #EEE;
      }

      iron-selector .iron-selected {
        background-color: #ccc;
      }

      label {
        display: block;
        margin-top: 5px;
        font-weight: 600;
      }
      
  </style>
  <template>
  
    <div class="lens-container lens-data">
      
      <!-- Load Google Maps API -->
      <google-maps-api on-api-load="apiReady"></google-maps-api>

      <!-- Firebase element for data storage -->
      <firebase-collection id="firebase" location="{{_updateFirebaseLocation(hash)}}" data="{{_firebaseData}}"></firebase-collection>
      
      <!-- Menu for selecting input column --> 
      <label for="label_selector">Select location column: </label> 
      <iron-selector id="label_selector" selected="{{selectedLabel}}" attr-for-selected="label">
        <template is="dom-repeat" items="{{_dataAttributes}}" as="attr">
          <div label="{{attr}}" class="col">{{attr}}</div>
        </template>
      </iron-selector>
      
      <!-- Progress and error details -->
      <!-- note: this does not work in case of fallback to google api-->
        <p><span>{{_firebaseData.length}}</span> of <span>{{input.length}}</span> locations processed.</p>

      <template is="dom-if" if="{{_computeIf(errors)}}">
        <p><span>{{errors.length}}</span> location(s) NOT found:</p>
        <template is="dom-repeat" items="{{errors}}" as="error">
          <li><strong> Location: </strong><span>{{error.location}}</span> <strong> Reason: </strong>{{error.reason}}</li>
        </template>
      </template>
    </div> 
    

  </template>
  <script>
    Polymer({
      is: 'lens-data-geocoder-firebase',
      properties: {
        firebaseLocation: {
          type: String,
          value: '',
          notify: true
        },
        _firebaseData: {
          type: Array,
          // value: function () {
            // return [];
          // },
          observer: '_firebaseDataChanged'
        },
        input: {
          notify: true,
          observer: '_inputChanged'
        },
        output: {
          notify: true,
          readOnly: true,
          observer: '_outputChanged'
        },
        reverseGeocode: { 
          notify: true 
        },
        selectedLabel: {
          notify: true,
          observer: '_selectedLabelChanged'
        }
      },

      apiReady: function () {
        var self = this;
        self.firebase = self.$.firebase;
        self.geocoder = new google.maps.Geocoder();
        self.geocodeFunc = self.reverseGeocode ? self._addLocationToFirebase : self._addGeocodeToFirebase;
        if (self.input && self.input.length) {
          // self._setupOutput();
          self._parseInput();
        }

      },

      _setupOutput: function () {
        var self = this;
        console.log('reset output');
        self._output = self.input.map(function (item) {
          // if input was an array of strings, return an object with that string as 'location'
          if (typeof item === 'string') {
            return { 'location': item }; // TODO: this is not a good way to detect location... to be fixed
          }
          var newItem = {};
          var keys = Object.keys(item);
          keys.forEach(function (key) {
            newItem[key] = item[key];
          });
          return newItem;
        });
      },

      _parseInput: function () {
        var self = this;
        console.log('parsing input');
        
        if (self.geocoder) {
          // Determine data structure of input and convert input to an array of strings
          switch (typeof self.input) {
          // Input is a string
          case 'string':
            self.inputLength = 1;
            self._geocoderInput = [self.input];
            break;
          // Input is an array or object
          case 'object':
            var length = self.input.length;
            if (length > 0) {
              self.inputLength = length;
              // Array of strings
              if (typeof self.input[0] === 'string') {
                self._geocoderInput = self.input;
              } else // Array of objects
              if (typeof self.input[0] === 'object') {
                self._dataAttributes = Object.keys(self.input[0]);
                if (self.selectedLabel) {
                  self._geocoderInput = self.input.map(function (obj) {
                    return obj[self.selectedLabel];
                  });
                  break;
                } else {
                  // self._geocoderInput = [];
                  break;
                }
              } else
                // Array of anything else
                {
                  console.log('Invalid input data');
                }
            } else
              // Single object              
              {
                self.inputLength = 1;
                self._dataAttributes = Object.keys(self.input);
                if (self.selectedLabel) {
                  self._geocoderInput = [self.input[self.selectedLabel]];
                } else {
                  break;
                }
              }
            break;
          // Input is something else
          default:
            console.log('Invalid input data');
          }
        }
        console.log('finished parsing input');
      },
      /**
       * _createHash - converts the input into a unique identifier, used as a key to save geocodes in firebase
       * @param  {Array} input - an array of strings, representing the locations that need geocodes
       * @return {String} hash - the resulting unique identifier
       */
      _createHash: function (input) {
        console.log('create hash');
        var input = input.toString(), inputLength = input.length;
        var hash = 0;
        var i, chr, len;
        if (inputLength == 0)
          return hash;
        for (i = 0; i < inputLength; i++) {
          chr = input.charCodeAt(i);
          hash = (hash << 5) - hash + chr;
          hash |= 0;
        }
        // Convert to 32bit integer
        return hash;
      },

      /**
       * _zipFirebaseDataWithInput - called when a response is received from firebase, and maps the response to the existing dataset
       * @param  {Array} geocodesArr - array of objects containing lat/lng coordinates and any potential errors
       */
      _zipFirebaseDataWithInput: function () {
        console.log('Zipping Firebase data with input data');
        var self = this;
        if (self._firebaseData && self._firebaseData.length){
          self.errors = [];
          var output = self.input.map(function (item) {
            // Clone input object
            var newItem = {}, 
                keys = Object.keys(item);
            keys.forEach(function (key) {
              newItem[key] = item[key];
            });

            // Match the input terms and add the lat/lng from firebase data to the newItem
            self._firebaseData.forEach(function (geocode) {
              if (geocode.input === item[self.selectedLabel]) {
                newItem.latitude = geocode.latitude;
                newItem.longitude = geocode.longitude;
                // Collect errors to display
                if (geocode.errors) {
                  self.errors.push(geocode.errors);
                }
              }
            });
            return newItem;
          });
          self._setOutput(output);
        }
      },

      _getLocations: function () {
        var self = this, inputLength, i = 0;
        if (!this._geocoderInput) {
          return;
        }
        self._setupOutput();
        inputLength = self._geocoderInput.length;
        if (!self.gettingLocations) {
          // self._firebaseData = []; 
          self.gettingLocations = true;
          var interval = setInterval(function () {
            self.geocodeFunc(self._geocoderInput[i], self._output[i]);
            i++;
            if (i === inputLength) {
              clearInterval(interval);
              self.gettingLocations = false;
            }
          }, 300);
        } else {
          console.log('already getting locations');
        }
      },
      // In case _getLocations() is called twice with the observers
      /**
       * '_addGeocodeToFirebase' adds lat and long to the object containing the location given
       * @param {string} input - representing a valid location or address
       * @param {object} outputItem - the object in the array to which geolocation object should be added to
       */
      _addGeocodeToFirebase: function (location, outputItem) {
        var self = this;
        self.geocoder.geocode({ 'address': location }, function (results, status) {
          if (status == google.maps.GeocoderStatus.OK) {
            
            // The names of the lat/long keys keep changing in the API but usually stay in the same order, so better to not hardcode them.
            var latLng = Object.keys(results[0].geometry.location);
            var lng = results[0].geometry.location[latLng[1]], 
                lat = results[0].geometry.location[latLng[0]];
           
            // Update _firebaseData
            var geocode = {
              'input': location,
              'latitude': lat,
              'longitude': lng
            };
            self.firebase.add(geocode);
            
            // Update _output (which is not read-only)
            outputItem.latitude = lat;
            outputItem.longitude = lng;
            
            // Update output (read-only)
            self._setOutput(self._output);
            self._outputChanged(); // Manually call outputChanged because observer does not detect deep changes

          } else {
            console.log('Geocode for ' + location + ' was not successful for the following reason: ' + status);
            if (status == 'OVER_QUERY_LIMIT') {
              setTimeout(function () {
                self._addGeocodeToFirebase(location);
              }, 1000);
            } else {
              // Update errors
              var error = {
                location: location,
                reason: status
              };
              self.errors.push(error);

              // Update _firebaseData
              var geocode = {
                'input': location,
                'latitude': '',
                'longitude': '',
                'error': error
              };
              self.firebase.add(geocode);
    
              // Update _output (which is not read-only)
              outputItem.latitude = '';
              outputItem.longitude = '';
            
              // Update output (read-only)
              self._setOutput(self._output);
              self._outputChanged(); // Manually call outputChanged because observer does not detect deep changes
            }
          }
        });
      },
      /**
       * '_addLocationToFirebase' adds an object containing the location and coordinates to the output array
       * @param {string} latlng - lat and long coordinates separated by comma
       * @param {object} outputItem - the object in the array to which geolocation object should be added to
       */
      // TODO: needs updating
      // TODO: allow for latlng to be given in different ways, or separately
      _addLocationToFirebase: function (latlng) {
        var self = this;
        if (typeof latlng === 'undefined') {
          return;
        }
        var latlngStr = latlng.split(',', 2), lat = parseFloat(latlngStr[0]), lng = parseFloat(latlngStr[1]), coordinates = new google.maps.LatLng(lat, lng);
        self.geocoder.geocode({ 'latLng': coordinates }, function (results, status) {
          if (status == google.maps.GeocoderStatus.OK) {
            var location = results[0].formatted_address;
            // outputItem.label = location;
            // // add to output. Key is "label"
            // self.output = self.output.map(function (item) {
            //   return item;
            // });
          } else {
            console.log('Geocode for ' + latlng + ' was not successful for the following reason: ' + status);
            if (status == 'OVER_QUERY_LIMIT') {
              setTimeout(function () {
                self._addLocationToFirebase(latlng);
              }, 1000);
            } else {
              self.errors.push({
                location: latlng,
                reason: status
              });
            }
          }
        });
      },
      _computeIf: function (errors) {
        return errors.length > 0;
      },
      _updateFirebaseLocation: function(hash){
        var hash = hash || '';
        this.firebaseLocation = 'https://shining-fire-6376.firebaseio.com/geocodes/' + hash;
        
        return this.firebaseLocation;
        

      },


      /** OBSERVERS **/

      // /**
      //  * _selectedLabelChanged calls the _inputChanged method when the selection changes
      //  * @return {[type]} [description]
      //  */
      // _selectionChanged: function () {
      //   console.log('geocoder selection changed');
      //   var self = this;
      //   self.output = [];
      //   // self._setupOutput();
      //   self.errors = [];
      //   if (self.input.length > 0) {
      //     self._geocoderInput = self.input.map(function (obj) {
      //       return obj[self.selectedLabel];
      //     });
      //   } else {
      //     self._geocoderInput = [self.input[self.selectedLabel]];
      //   }
      // },

      /**
       * _inputChanged - when input changes, reset the outputs, and send it back through the parser
       * @return {[type]} [description]
       */
      _inputChanged: function () {
        var self = this;
        self.fire('lens-input-changed', self);
        // self._setupOutput();
        self.errors = [];
        self._parseInput();
        self._selectedLabelChanged();
      },
      /**
       * _firebaseDataChanged - when the output for firebase is finished, call saveToFirebase()
       */
      _firebaseDataChanged: function () {
        var self = this;
        if ((self._firebaseData && self.input) && (self._firebaseData.length === self.input.length)){
          console.log('Data received from Firebase, ready to zip with input');
          self._zipFirebaseDataWithInput();
        } 
      },
      /**
       * _selectedLabelChanged - when selection changes, clear the results and restart the process of geocoding
       */
      _selectedLabelChanged: function () {
        console.log('geocoder-firebase selection changed');
        var self = this;
        self.errors = [];

        self._parseInput();

        if (self._geocoderInput){
          self.hash = self._createHash(self._geocoderInput);
                  
          // Wait 0.5s for retrieval of data from Firebase (there does not seem to be any event/callback for query response)
          setTimeout(function(){
            if (self.hash && self.selectedLabel && (!self._firebaseData || !self._firebaseData.length)) {
              console.log('No data in Firebase. Getting geocodes from Google API.');
              self._getLocations();
            } else {
              self._firebaseDataChanged();
            }
          },500)
        }

      },

      /**
       * _outputChanged - when output changes, check if the entire output is ready and fire an event
       * @return {[type]} [description]
       */
      _outputChanged: function () {
        console.log(this.output);
        this.fire('lens-output-changed', this.output);
        // When output is ready, fire event for other components to use
        // if (self.output.length === self.inputLength) {
        //   if (self.output[self.output.length - 1]['latitude'] && self.output[self.output.length - 1]['longitude']) {
        //     console.log('geocoder output ready');
        //     self.fire('lens-output-ready', self.output);
        //   }
        // }
      },
    });
  </script>
</dom-module>